initSidebarItems({"constant":[["MZ_ADLER32_INIT",""],["MZ_BLOCK",""],["MZ_BUF_ERROR",""],["MZ_CRC32_INIT",""],["MZ_DATA_ERROR",""],["MZ_DEFAULT_STRATEGY",""],["MZ_DEFAULT_WINDOW_BITS",""],["MZ_DEFLATED",""],["MZ_ERRNO",""],["MZ_FILTERED",""],["MZ_FINISH",""],["MZ_FIXED",""],["MZ_FULL_FLUSH",""],["MZ_HUFFMAN_ONLY",""],["MZ_NEED_DICT",""],["MZ_NO_FLUSH",""],["MZ_OK",""],["MZ_PARAM_ERROR",""],["MZ_PARTIAL_FLUSH",""],["MZ_RLE",""],["MZ_STREAM_END",""],["MZ_STREAM_ERROR",""],["MZ_SYNC_FLUSH",""],["MZ_VERSION_ERROR",""]],"enum":[["mz_internal_state","Unused opaque pointer."]],"fn":[["def_alloc_func","Default allocation function using `malloc`."],["def_free_func","Default free function using `free`."],["miniz_def_alloc_func",""],["miniz_def_free_func",""],["miniz_def_realloc_func",""],["mz_adler32",""],["mz_adler32_oxide",""],["mz_compress",""],["mz_compress2",""],["mz_compress2_oxide",""],["mz_compressBound",""],["mz_crc32",""],["mz_crc32_oxide",""],["mz_deflate",""],["mz_deflateBound",""],["mz_deflateEnd",""],["mz_deflateInit",""],["mz_deflateInit2",""],["mz_deflateReset",""],["mz_deflate_end_oxide","Free the inner compression state."],["mz_deflate_init2_oxide","Initialize the compressor with the requested parameters."],["mz_deflate_init_oxide","Initialize the wrapped compressor with the requested level (0-10) and default settings."],["mz_deflate_oxide",""],["mz_deflate_reset_oxide","Reset the compressor, so it can be used to compress a new set of data."],["mz_inflate",""],["mz_inflateEnd",""],["mz_inflateInit",""],["mz_inflateInit2",""],["mz_inflate_end_oxide",""],["mz_inflate_init2_oxide",""],["mz_inflate_init_oxide",""],["mz_inflate_oxide",""],["mz_uncompress",""],["mz_uncompress2_oxide",""],["tdefl_allocate","Allocate a compressor."],["tdefl_compress",""],["tdefl_compress_buffer",""],["tdefl_compress_mem_to_heap",""],["tdefl_compress_mem_to_mem",""],["tdefl_compress_mem_to_output",""],["tdefl_create_comp_flags_from_zip_params",""],["tdefl_deallocate","Deallocate the compressor. (Does nothing if the argument is null)."],["tdefl_get_adler32",""],["tdefl_get_prev_return_status",""],["tdefl_init","Initialize the compressor struct in the space pointed to by `d`. if d is null, an error is returned."],["tinfl_decompress",""],["tinfl_decompress_mem_to_heap","Decompress data from `p_src_buf` to a continuously growing heap-allocated buffer."],["tinfl_decompress_mem_to_mem",""]],"macro":[["unmangle","Unmangle the wrapped functions if no_c_export is not defined. For benchmarks, and other comparisons where we want to have both the miniz and miniz_oxide functions available, functions shouldn not be marked `no_mangle` since that will cause conflicts."]],"mod":[["lib_oxide","This module mainly contains functionality replicating the miniz higher level API."],["return_status",""]],"struct":[["StreamOxide",""],["StreamWrapper",""],["inflate_state",""],["mz_stream","Inner stream state containing pointers to the used buffers and internal state."],["tdefl_compressor","Main compression struct. Not the same as `CompressorOxide`"],["tinfl_decompressor","Main decompression struct."]],"trait":[["StateType","Trait used for states that can be carried by BoxedState."]],"type":[["MZResult",""],["mz_alloc_func","Signature of function used to allocate the compressor/decompressor structs."],["mz_free_func","Signature of function used to free the compressor/decompressor structs."]]});